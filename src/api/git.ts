import * as core from '@actions/core'
import * as fs from 'fs'
import { GitHubApiClient } from '../api/github'
import { simpleGit } from 'simple-git'
import { parsePatch, ParsedDiff } from 'diff'
import { exec } from 'child_process'

export class GitClient {
  private git

  constructor(token: string) {
    this.git = simpleGit({
      baseDir: process.cwd(),
      binary: 'git',
      maxConcurrentProcesses: 6,
      trimmed: false
    })
    // Configure git
    this.git.addConfig('user.name', 'Action Copilot')
    this.git.addConfig('user.email', 'copilot@warestack.com')
    this.git.addConfig('http.extraHeader', `Authorization: token ${token}`)
  }

  /**
   * Clone a repository from GitHub using the provided token, repository owner, repository name, and branch.
   *
   * @param {string} repoOwner - The owner of the repository.
   * @param {string} repoName - The name of the repository.
   * @param {string} branch - The branch to clone.
   * @return {Promise<void>} - A promise that resolves when the repository has been cloned successfully, or rejects with an error if the cloning process encounters an error.
   * @throws {Error} - If an error occurs during the cloning process.
   */
  async clone(
    repoOwner: string,
    repoName: string,
    branch: string
  ): Promise<void> {
    const repoUrl = `https://github.com/${repoOwner}/${repoName}.git`
    try {
      await this.git.clone(repoUrl, '.', [
        '--depth',
        '1',
        '-b',
        branch,
        '--single-branch'
      ])
    } catch (error) {
      if (error instanceof Error) {
        core.error(`Error cloning repository: ${error.message}`)
        throw error
      }
      throw new Error('Error cloning repository')
    }
  }

  async patchCommitAndPush(
    patchContent: string,
    commitMessage: string,
    newBranchName: string
  ): Promise<void> {
    try {
      // Change to the repository directory if not already there
      process.chdir(process.env.GITHUB_WORKSPACE || '')
      // Decode URL encoded characters

      const patchCon = `--- a/.github/workflows/setup_and_test.yaml
+++ b/.github/workflows/setup_and_test.yaml
@@ -28,7 +28,7 @@ jobs:
           --name mongo_container
     env:
       JOB_STATUS: succeeded
-      DATABASE_URL: mongodb://locahost:27017
+      DATABASE_URL: mongodb://localhost:27017
       DATABASE_NAME: bsc_computing_project`

      // let decodedPatch = decodeURIComponent(patchContent)
      // // Remove markdown backticks
      // decodedPatch = decodedPatch.replace(/```diff|```/g, '').trim()
      // // Convert to actual JavaScript string with proper new lines if necessary
      // patchContent = patchContent.replace(/%0A/g, '')

      // const patch: ParsedDiff = parsePatch(patchContent)[0]
      // const serializedPatch = [
      //   `--- ${patch.oldFileName}`,
      //   `+++ ${patch.newFileName}`,
      //   ...patch.hunks.map(hunk => {
      //     return [
      //       `@@ -${hunk.oldStart},${hunk.oldLines} +${hunk.newStart},${hunk.newLines} @@`,
      //       ...hunk.lines
      //     ].join('\n')
      //   })
      // ].join('\n')
      const patchFile = 'temp.patch'
      // Write the patch content to a file
      fs.writeFileSync(patchFile, `${patchCon.trim()}\n`, 'utf-8')
      // Apply the patch
      // await this.git.applyPatch(patchFilePath)
      // await this.git.applyPatch(patchFile)
      exec('git fetch --all')
      core.debug(await this.git.listRemote())
      exec(`git checkout -b ${newBranchName}`)
      exec(
        `git apply --recount --ignore-space-change --ignore-whitespace ${patchFile}`,
        (error, stdout, stderr) => {
          if (error) {
            console.error(`Error: ${error.message}`)
            return
          }
          if (stderr) {
            console.error(`stderr: ${stderr}`)
            return
          }
          console.log(`stdout: ${stdout}`)
          console.log('Patch applied successfully.')
        }
      )

      exec(`git commit -am ${commitMessage}`)
      exec(`git push -u origin ${newBranchName}`)
    } catch (error) {
      if (error instanceof Error) {
        core.error(`Error patching, committing and pushing: ${error.message}`)
        throw error
      }
      throw new Error('Error patching, committing and pushing')
    }
  }

  /**
   * Applies a patch and creates a pull request with the changes.
   *
   * @param {GitHubApiClient} githubClient - The GitHub API client instance.
   * @param {string} repoOwner - The repository owner.
   * @param {string} repoName - The repository name.
   * @param {string} baseBranch - The base branch to create the pull request against.
   * @param {string} patchContent - The patch content generated by the AI.
   * @param {string} commitMessage - The commit message for the changes.
   * @param {string} prTitle - The title of the pull request.
   * @param {string} prBody - The body of the pull request.
   * @returns {Promise<string>} The URL of the created pull request.
   */
  async createPullRequest(
    githubClient: GitHubApiClient,
    repoOwner: string,
    repoName: string,
    baseBranch: string,
    patchContent: string,
    commitMessage: string,
    prTitle: string,
    prBody: string
  ): Promise<string> {
    // Assuming the patch is valid and can be applied cleanly
    try {
      // Apply the patch
      // await this.git.raw(['apply', '--whitespace=nowarn', '-'], patchContent)
      // Add changes to the index
      await this.git.add('.')
      // Commit the changes
      await this.git.commit(commitMessage)
      // Push changes to a new branch
      const branchName = `ai-fix-${Date.now()}`
      await this.git.push('origin', `HEAD:refs/heads/${branchName}`)
      // Create a pull request
      const prUrl = await githubClient.createPullRequest(
        repoOwner,
        repoName,
        baseBranch,
        branchName,
        prTitle,
        prBody
      )

      core.info(`Pull request created: ${prUrl}`)
      return prUrl
    } catch (error) {
      if (error instanceof Error) {
        core.error(`Failed to create a pull request: ${error.message}`)
        throw error
      }
      throw new Error('Unknown error occurred while creating a pull request')
    }
  }
}
